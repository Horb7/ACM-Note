# 背包问题

## 01背包

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010, M = 1010;

// 模板：n个物品，有体积v和价值w，把它放进V体积的背包的最大价值
// 状态：从前i个物品中选择若干个，容量限制为j时能够获得的最大价值 i [0, n] j [w, W]
// 初始：f(0, j) = 0, 选0个物品，对于任何限制，最大价值都是0
// 决策：对于当前物品，每个状态都可以由两个来源，取max
// - 不选择第 i 个物品，f(i-1, j) -> f(i, j)
// - 选择第 i 个物品，f(i-1, j-w) + v -> f(i, j) j>=w
// 最优解为 f(W)
// 模板题：https://www.luogu.com.cn/problem/P1048
int zeroOneKnapsack (int n, int vals[], int weights[], int W)
{
    int dp[N]; // dp(i) 背包为i时能装的最大价值
    for (int i = 1; i <= n; i ++ )
        for (int j = W; j >= weights[i]; i -- ) {
            int v = vals[i], w = weights[i];
            dp[j] = max(dp[j], dp[j - w] + v);
        }
    return dp[W];
}

// EXTRA: n个物品，装入体积至少为W，求价值和的最小值
// 01分数规划 + 01背包 https://www.luogu.com.cn/problem/P4377
int zeroOneLeastKnapsack (int n, int vals[], int weights[], int W)
{
    int dp[N];
    fill(dp + 1, dp + n + 1, 1e9); // 初始化dp, 1e9 or 1e18
    dp[0] = 0;

    for (int i = 1; i <= n; i ++ )
        for (int j = W; j >= 0; j -- ) {
            int v = vals[i], w = weights[i];
            int ws = min(W, j + w);
            dp[ws] = min(dp[ws], dp[j] + v);
        }


    /* 另一种写法
    for (int i = 1; i <= n; i++)
        for (int j = W; j >= 0; j--) {
            int v = vals[i], w = weights[i];
            dp[j] = min(dp[j], dp[max(0, j - w)] + v); // max(0, j-w)蕴含了“至少”,有点"堆积"的感觉
        }
    */


    return dp[W];
}

// EXTRA: 打印字典序最小的方案
// 倒序遍历物品，同时使用fa数组记录转移来源
vector<int> GetLexicographicSmallestResult (int n, int vals[], int weights[], int W)
{
    // use zeroOneKnapsack
    int dp[N], fa[N][M]; // fa(i, j)表示对于前i个数字，j容量背包通过哪个背包转移过来
    for (int i = 1; i <= n; i ++ ) {
        for (int j = 0; j <= W; j ++ ) fa[i][j] = j; // 假设不选
        for (int j = W; j >= weights[i]; j--) {
            int v = vals[i], w = weights[i];
            if (dp[j - w] + v > dp[j]) { // 注意不要取等于，保证字典序最小
                dp[j] = dp[j - w] + v;
                fa[i][j] = j - w;
            }
        }
    }
    // 倒序遍历物品
    vector<int> ans;
    for (int i = n, j = W; i >= 1; i -- ) {
        if (fa[i][j] == j) -- i;
        else {
            ans.push_back(i);
            j = fa[i][j];
            i -- ; // 一个物品只能装一次，如果是完全背包，去掉这一句
        }
    }
    reverse(ans.begin(), ans.end());
    return ans;
}

// EXTRA: 从序列 a 中选择若干个数，使其总和为 sum 的方案数
// NOTE: 判断能否达到 sum ,使用bitset或者开bool型dp
// 转换: https://ac.nowcoder.com/acm/contest/23106/A
// 转换: https://codeforces.com/contest/1637/problem/D
int zeroOneWaysToSum (int n, int vals[], int S)
{
    int dp[N];
    dp[0] = 1; // 全部不选到达0，初始条件
    for (int i = 1; i <= n; i ++ )
        for (int j = S; j >= vals[i]; j -- ) {
            int v = vals[i];
            dp[j] += dp[j - v]; // % mod
        }
    return dp[S];

    // 判定性(使用bitset): 能否到达sum
    bitset<N> f;
    f[0] = 1;
    for (int i = 1; i <= n; i ++ )
        f |= f << vals[i];
    return f[S];
}


int main () {
    return 0;
}
```



____

## 多重背包

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;

// 模板: n个物品, 有体积和价值, 每个物品有若干数量, 问容量为W的背包能放最大多少价值的物品
// 每个数字都能转化为若干个二进制数相加，把每个物品的数量转化为若干个二进制数，然后就是01背包了
int boundedKnapsackBinary (int n, int vals[], int weights[], int numbers[], int W)
{
    int dp[N];

    auto calc = [&](int v, int w) {
        for (int j = W; j >= w; j -- )
            dp[j] = max(dp[j], dp[j - w] + v);
    };

    for (int i = 1; i <= n; i ++ ) {
        int v = vals[i], w = weights[i], num = numbers[i], cnt = 1; // cnt为当前二进制数
        while(cnt <= num) {
            calc(v * cnt, w * cnt); // 进行一次01背包
            num -= cnt; // 剩余数量
            cnt <<= 1;
        }
        if (num) { // 剩余的直接再做一次01背包
            calc(v * num, w * num);
        }
    }

    return dp[W];
}

// EXTRA 多重背包计数(前缀和优化)
// https://www.luogu.com.cn/problem/P1077

int main () {
    return 0;
}
```





____


## 树上背包/依赖背包

模板题，一棵树的例题: https://www.acwing.com/problem/content/description/10/

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 110, M = 10010;
int n, root, v[N], w[N], V;
int dp[N][M]; // 用j容量的背包，选择以i为根的子树，且i被选择
vector<int> g[N];

void dfs (int u)
{
    // 选择u
    for (int j = V; j >= v[u]; j -- ) dp[u][j] = w[u];
    // 选择子节点
    for (int s: g[u]) {
        dfs(s);
        for (int j = V; j >= v[u]; j -- ) // 给以u为根的这棵树分配多少容量
            for (int k = j - v[u]; k >= 0; k -- ) // 给s儿子分配多少容量
                dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[s][k]);
    }
}

int main ()
{
    cin >> n >> V;
    for (int i = 1, p; i <= n; i ++ ) {
        cin >> v[i] >> w[i] >> p;
        if (p == -1) root = i;
        else g[p].push_back(i);
    }
    dfs(root);
    cout << dp[root][V] << endl;
    return 0;
}
```

当题目给定了多棵树：金明的预算方案 https://www.acwing.com/problem/content/489/

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

typedef pair<int, int> PII;

const int N = 60, M = 35000;

int n, m;
PII master[N];
vector<PII> servent[N];
int f[M];

int main () {
    cin >> m >> n;
    for (int i = 1; i <= n; i++) {
        int v, p, q; cin >> v >> p >> q;
        if (!q) master[i] = {v, v * p};
        else servent[q].push_back({v, v * p});
    }

    for (int i = 1; i <= n; i++) {
        for (int u = m; u >= 0; u --) {
            // 二进制枚举选择哪些附件，对这种情况做01背包
            for (int j = 0; j < 1 << servent[i].size(); j++) {
                int v = master[i].first, w = master[i].second;
                for (int k = 0; k < servent[i].size(); k++) {
                    if (j >> k & 1) {
                        v += servent[i][k].first;
                        w += servent[i][k].second;
                    }
                }
                if (u >= v) f[u] = max(f[u], f[u - v] + w);
            }
        }
    }

    cout << f[m] << endl;
}
```



____

