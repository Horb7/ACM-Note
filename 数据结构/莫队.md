# 莫队

莫队是分块算法的一种重要形式，它是 **对询问进行分块** ，即把询问离线下来，对询问序列进行分块，然后在 $O(n \sqrt n)$ 复杂度内得出所有答案。

// ==TODO== 莫队题单 https://www.luogu.com.cn/training/2914#problems

## 普通莫队

如果一个询问可以在 $O(1)$ 的时间内将 $[l, r]$ 的询问答案转移到 $[l-1, r], [l+1, r], [l, r-1], [l, r+1]$ ，也就是与 $[l, r]$ 相邻区间的答案， 那么就可以使用莫队算法。

具体来说，我们将询问分块后，对于每一个区间，我们按照暴力解决第一个区间 $[l, r]$ 的询问，然后对于询问 $[l', r']$ ，我们**以上一次询问的答案作为基础** ，每次 $O(\sqrt n)$ 地处理上一个区间左端和右端多出或者减少的部分，然后就可以得到这个问题的答案。

为了保证每次将上一个区间 $[l, r]$ 转移到这个区间的复杂度为 $O(\sqrt n)$ ，需要对询问序列进行排序，先整体按照 $l$ 排序，然后对于分块后的序列，每个块内部按照 $r$ 来排序。

下面的模板来自于 oi-wiki 。

```c++
void move (int pos, int sign) {
    // update nowAns
}

void solve () {
    // some info
    sort(querys, querys + m);
    for (int i =  0; i < m; i ++ ) {
        const query &q = query[i];
        while (l > q.l) move(--l, 1);
        while (r < q.r) move(r++, 1);
        while (l < q.l) move(l++, -1);
        while (r > q.r) move(--r, -1);
        ans[q.id] = nowAns;
    }
}
```

复杂度分析就不写在这了。~~本蒟蒻根本看不懂~~ 

只提一嘴：在 $m$ 和 $n$ 同阶的时候块长可以分为 $\sqrt n$ ，如果不同阶，块长取 $\dfrac n {\sqrt m}$ 是最优解，复杂度达到 $n \sqrt m$ 。

还有个**莫队优化**，使用奇偶化排序，对于奇数块，$r$ 从小到大排序，对于偶数块，$r$ 从大到小排序，这样可以优化 $r$ 指针的移动次数。

```c++
int len; // 块长
struct Node {
    int l, r, id;
    
    bool operator< (const Node &rhs) const {
        if (l / len != rhs.l / len) return l < rhs.l; // 整体排序, 不在同一个块按照l排序
        if ((l / len) & 1) return r < rhs.r; // 奇数块, r从小到大
        else return r > rhs.r; // 偶数块，r从大到小
    }
}
```



还有个需要注意的点，$l$ 和 $r$ 指针的移动不是任意顺序的，简单点就是只有下面几种情况是正确的：

![image-20220330210027401](D:\Horb7\ACM笔记\数据结构\pic\moduipoint.png)



典中典题目：[小Z的袜子](https://www.luogu.com.cn/problem/P1494)

题意就是问 $[l, r]$ 中选择任意两个数字，是相同数字的概率为多少。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 50010;
int n, m, c[N], cnt[N], maxn;
ll ans1[N], ans2[N], sum;

struct query {
    int l, r, id;
    bool operator< (const query& rhs) const {
        if (l / maxn != rhs.l / maxn) return l < rhs.l;
        if (l / maxn & 1) return r < rhs.r;
        else return r > rhs.r;
    }
} a[N];

void add (int i) {
    sum += cnt[i];
    ++ cnt[i];
}

void del (int i) {
    -- cnt[i];
    sum -= cnt[i];
}

int main ()
{
    cin >> n >> m;
    maxn = sqrt(n);
    for (int i = 1; i <= n; i ++ ) cin >> c[i];
    for (int i = 1; i <= m; i ++ ) {
        int l, r; cin >> l >> r;
        a[i] = { l, r, i };
    }
    sort(a + 1, a + m + 1);
    for (int i = 1, l = 1, r = 0; i <= m; i ++ ) {
        if (a[i].l == a[i].r) {
            ans1[a[i].id] = 0, ans2[a[i].id] = 1;
            continue;
        }
        while(l > a[i].l) add(c[-- l]);
        while(r < a[i].r) add(c[++ r]);
        while(l < a[i].l) del(c[l ++ ]);
        while(r > a[i].r) del(c[r -- ]);
        ans1[a[i].id] = sum;
        ans2[a[i].id] = (ll)(r - l + 1) * (r - l) / 2;
    }
    for (int i = 1; i <= m; i ++ ) {
        if (ans1[i] == 0) {
            cout << "0/1" << endl;
            continue;
        }
        ll g = __gcd(ans1[i], ans2[i]);
        ans1[i] /= g, ans2[i] /= g;
        cout << ans1[i] << '/' << ans2[i] << endl;
    }
    return 0;
}
```

模板题：https://www.luogu.com.cn/problem/P2709

莫队+树状数组维护区间：https://www.luogu.com.cn/problem/P4396

莫队+异或前缀：https://www.luogu.com.cn/problem/P4462



## 带修莫队

普通莫队不支持修改，我们可以多加一个时间维度，这样就**把线性分块变成了平面分块**了，我们对询问按照如下规则排序：

1. 先按照左端点整体排序分块，这样就变成了线性分块问题了。
2. 与普通莫队分块规则相同，按右端点整体排序分块，在一个块内，按照时间排序。

```c++
int maxn; // 块长
struct query {
    int l, r, i, c; // i表示操作id, c表示在第几个修改操作的后面

    bool operator< (const query &rhs) const {
        if (l / maxn != rhs.l / maxn) return l < rhs.l;
        // 对r奇偶化排序
        if (r / maxn != rhs.r / maxn) {
            if (l / maxn & 1) return r < rhs.r;
            else return r > rhs.r;
        }
        // 对i奇偶化排序
        if (r / maxn & 1) return i < rhs.i;
        else return i > rhs.i;
    }
};
```

**注意这样其实就是分块两次，然后按时间排序，因此可以使用两次奇偶化排序。**

然后修改的时候其实就是把三个偏移量 $[l, r, time]$ 全部移动到当前的询问状态。我们可以先把 $time$ 移动好，然后移动 $[l, r]$ 就和普通莫队一样了。

带修莫队的时间复杂度为 $n^{\frac 5 3}$ ，块长一般开成 $n^{\frac 2 3}$ 。

虽然时间复杂度看起来比较那个，但是还是能解决 1e5 左右的数据。

典中典题目：[洛谷P1903 [国家集训队] 数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903) 

题意：

1. 查询 $[l, r]$ 区间不同的数字的个数。
2. 把第 $x$ 个数字修改为 $y$ 。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 140010, M = 1000010;
int n, m, c[N], ct[N]; // ct(i)为c(i)元素修改后的数值
int maxn, len;

struct query {
    int l, r, i, c; // c表示在第几个修改操作的后面

    bool operator< (const query &rhs) const {
        if (l / maxn != rhs.l / maxn) return l < rhs.l;
        if (r / maxn != rhs.r / maxn) {
            if (l / maxn & 1) return r < rhs.r;
            else return r > rhs.r;
        }
        if (r / maxn & 1) return i < rhs.i;
        else return i > rhs.i;
    }
} q[N];

char op[10];
int c1, c2; // query和change的次数
int tot[M], mem[N][3]; // mem保存change的信息
int ans[N], res;

void add (int a) {
    if (!tot[a]) ++ res;
    ++ tot[a];
}

void del (int a) {
    -- tot[a];
    if (!tot[a]) -- res;
}

int main ()
{
    scanf("%d%d", &n, &m);
    maxn = (int)pow(n*1.0, 2.0/3); // 块长
    for (int i = 1; i <= n; i ++ ) scanf("%d", &c[i]), ct[i] = c[i];
    for (int i = 1; i <= m; i ++ ) {
        int a, b; scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'Q') {
            q[c1].l = a, q[c1].r = b;
            q[c1].i = c1, q[c1].c = c2;
            c1 ++ ;
        } else {
            // mem[][0]为修改的位置, mem[][1]为修改前的颜色，mem[][2]为修改后的颜色
            mem[c2][0] = a, mem[c2][1] = ct[a], mem[c2][2] = (ct[a] = b);
            c2 ++ ;
        }
    }
    sort(q, q + c1);
    int l = 1, r = 0, lst = 0; // [l, r]是上次的答案区间，lst是上次修改时间的后一位
    for (int i = 0; i < c1; i ++ ) {
        // 先修改时间维度
        for (; lst < q[i].c; lst ++ ) {
            if (l <= mem[lst][0] && mem[lst][0] <= r) {
                del(mem[lst][1]), add(mem[lst][2]);
            }
            // 注意修改原数组, 避免后面拓展到这个边界的时间用到了旧的元素
            c[mem[lst][0]] = mem[lst][2];
        }
        for (; lst > q[i].c; lst -- ) {
            if (l <= mem[lst-1][0] && mem[lst-1][0] <= r) {
                del(mem[lst-1][2]), add(mem[lst-1][1]);
            }
            c[mem[lst-1][0]] = mem[lst-1][1];
        }
        // 转移区间
        while(l > q[i].l) add(c[-- l]);
        while(r < q[i].r) add(c[++ r]);
        while(l < q[i].l) del(c[l ++ ]);
        while(r > q[i].r) del(c[r -- ]);
        ans[q[i].i] = res;
    }
    for (int i = 0; i < c1; i ++ ) printf("%d\n", ans[i]);
    return 0;
}
```

